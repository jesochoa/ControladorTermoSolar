#include "sh1106.h"
#include "freertos/FreeRTOS.h"
#include "esp_log.h"

#define TAG "SH1106"

// Fuente básica 5x7 (caracteres ASCII 32-126)
const uint8_t font_5x7[] = {
    0x00,0x00,0x00,0x00,0x00, // space
    0x00,0x00,0x5F,0x00,0x00, // !
    0x00,0x07,0x00,0x07,0x00, // "
    0x14,0x7F,0x14,0x7F,0x14, // #
    0x24,0x2A,0x7F,0x2A,0x12, // $
    0x23,0x13,0x08,0x64,0x62, // %
    0x36,0x49,0x55,0x22,0x50, // &
    0x00,0x05,0x03,0x00,0x00, // '
    0x00,0x1C,0x22,0x41,0x00, // (
    0x00,0x41,0x22,0x1C,0x00, // )
    0x08,0x2A,0x1C,0x2A,0x08, // *
    0x08,0x08,0x3E,0x08,0x08, // +
    0x00,0x50,0x30,0x00,0x00, // ,
    0x08,0x08,0x08,0x08,0x08, // -
    0x00,0x60,0x60,0x00,0x00, // .
    0x20,0x10,0x08,0x04,0x02, // /
    0x3E,0x51,0x49,0x45,0x3E, // 0
    0x00,0x42,0x7F,0x40,0x00, // 1
    0x42,0x61,0x51,0x49,0x46, // 2
    0x21,0x41,0x45,0x4B,0x31, // 3
    0x18,0x14,0x12,0x7F,0x10, // 4
    0x27,0x45,0x45,0x45,0x39, // 5
    0x3C,0x4A,0x49,0x49,0x30, // 6
    0x01,0x71,0x09,0x05,0x03, // 7
    0x36,0x49,0x49,0x49,0x36, // 8
    0x06,0x49,0x49,0x29,0x1E, // 9
    0x00,0x36,0x36,0x00,0x00, // :
    0x00,0x56,0x36,0x00,0x00, // ;
    0x08,0x14,0x22,0x41,0x00, // <
    0x14,0x14,0x14,0x14,0x14, // =
    0x00,0x41,0x22,0x14,0x08, // >
    0x02,0x01,0x51,0x09,0x06, // ?
    0x32,0x49,0x79,0x41,0x3E, // @
    0x7E,0x11,0x11,0x11,0x7E, // A
    0x7F,0x49,0x49,0x49,0x36, // B
    0x3E,0x41,0x41,0x41,0x22, // C
    0x7F,0x41,0x41,0x22,0x1C, // D
    0x7F,0x49,0x49,0x49,0x41, // E
    0x7F,0x09,0x09,0x09,0x01, // F
    0x3E,0x41,0x49,0x49,0x7A, // G
    0x7F,0x08,0x08,0x08,0x7F, // H
    0x00,0x41,0x7F,0x41,0x00, // I
    0x20,0x40,0x41,0x3F,0x01, // J
    0x7F,0x08,0x14,0x22,0x41, // K
    0x7F,0x40,0x40,0x40,0x40, // L
    0x7F,0x02,0x0C,0x02,0x7F, // M
    0x7F,0x04,0x08,0x10,0x7F, // N
    0x3E,0x41,0x41,0x41,0x3E, // O
    0x7F,0x09,0x09,0x09,0x06, // P
    0x3E,0x41,0x51,0x21,0x5E, // Q
    0x7F,0x09,0x19,0x29,0x46, // R
    0x46,0x49,0x49,0x49,0x31, // S
    0x01,0x01,0x7F,0x01,0x01, // T
    0x3F,0x40,0x40,0x40,0x3F, // U
    0x1F,0x20,0x40,0x20,0x1F, // V
    0x7F,0x20,0x18,0x20,0x7F, // W
    0x63,0x14,0x08,0x14,0x63, // X
    0x07,0x08,0x70,0x08,0x07, // Y
    0x61,0x51,0x49,0x45,0x43, // Z
    0x00,0x7F,0x41,0x41,0x00, // [
    0x02,0x04,0x08,0x10,0x20, // backslash
    0x00,0x41,0x41,0x7F,0x00, // ]
    0x04,0x02,0x01,0x02,0x04, // ^
    0x40,0x40,0x40,0x40,0x40, // _
    0x00,0x01,0x02,0x04,0x00, // `
    0x20,0x54,0x54,0x54,0x78, // a
    0x7F,0x48,0x44,0x44,0x38, // b
    0x38,0x44,0x44,0x44,0x20, // c
    0x38,0x44,0x44,0x48,0x7F, // d
    0x38,0x54,0x54,0x54,0x18, // e
    0x08,0x7E,0x09,0x01,0x02, // f
    0x08,0x14,0x54,0x54,0x3C, // g
    0x7F,0x08,0x04,0x04,0x78, // h
    0x00,0x44,0x7D,0x40,0x00, // i
    0x20,0x40,0x44,0x3D,0x00, // j
    0x7F,0x10,0x28,0x44,0x00, // k
    0x00,0x41,0x7F,0x40,0x00, // l
    0x7C,0x04,0x18,0x04,0x78, // m
    0x7C,0x08,0x04,0x04,0x78, // n
    0x38,0x44,0x44,0x44,0x38, // o
    0x7C,0x14,0x14,0x14,0x08, // p
    0x08,0x14,0x14,0x18,0x7C, // q
    0x7C,0x08,0x04,0x04,0x08, // r
    0x48,0x54,0x54,0x54,0x20, // s
    0x04,0x3F,0x44,0x40,0x20, // t
    0x3C,0x40,0x40,0x20,0x7C, // u
    0x1C,0x20,0x40,0x20,0x1C, // v
    0x3C,0x40,0x30,0x40,0x3C, // w
    0x44,0x28,0x10,0x28,0x44, // x
    0x0C,0x50,0x50,0x50,0x3C, // y
    0x44,0x64,0x54,0x4C,0x44, // z
};

SH1106::SH1106(i2c_master_dev_handle_t dev_handle) : device_handle(dev_handle)
{
    memset(oled_buffer, 0, sizeof(oled_buffer));
}

SH1106::~SH1106()
{
    // La destrucción del dispositivo I2C se maneja en el main
}

bool SH1106::writeCommand(uint8_t cmd)
{
    uint8_t buffer[2] = {0x00, cmd};
    esp_err_t ret = i2c_master_transmit(device_handle, buffer, sizeof(buffer), 1000 / portTICK_PERIOD_MS);
    return (ret == ESP_OK);
}

bool SH1106::writeData(const uint8_t *data, size_t len)
{
    uint8_t *buffer = (uint8_t *)malloc(len + 1);
    if (!buffer)
        return false;

    buffer[0] = 0x40; // Co=0, D/C=1 (datos)
    memcpy(&buffer[1], data, len);

    esp_err_t ret = i2c_master_transmit(device_handle, buffer, len + 1, 1000 / portTICK_PERIOD_MS);
    free(buffer);
    return (ret == ESP_OK);
}

void SH1106::setPosition(uint8_t page, uint8_t column)
{
    writeCommand(0xB0 + page);                   // Establecer página (0-19)
    writeCommand(0x00 + (column & 0x0F));        // Columna baja
    writeCommand(0x10 + ((column >> 4) & 0x0F)); // Columna alta
}

bool SH1106::init()
{
    uint8_t init_cmds[] = {
        SET_DISP | 0x00,            // Display OFF

        // Configuración para 128x64
        SET_DISP_START_LINE | 0x00, // Set display start line to 0
        SET_SEG_REMAP | 0x01,       // Remap segments Horizontal
        SET_SCAN_DIR | 0x08,        // Com scan direction

        SET_MEM_ADDR_MODE, 0x00,    // Horizontal addressing mode
        SET_COM_PIN_CFG, 0x12,      // Sequential COM pin config
        SET_CONTRAST, 0x80,         // Contrast
        SET_ENTIRE_ON,              // Disable entire display on
        SET_NORM_INV,               // Normal display
        SET_DISP_OFFSET, 0x00,      // No offset
        SET_CLK_DIV, 0x80,          // Set clock divide ratio
        SET_PRECHARGE, 0xF1,        // Pre-charge period
        SET_VCOM_DESEL, 0x30,       // VCOMH deselect level
        SET_DISP | 0x01             // Display ON
    };

    for (size_t i = 0; i < sizeof(init_cmds); i++)
    {
        if (!writeCommand(init_cmds[i]))
        {
            ESP_LOGE(TAG, "Error enviando comando: 0x%02X", init_cmds[i]);
            return false;
        }
        vTaskDelay(pdMS_TO_TICKS(2));
    }
    return true;
}


bool SH1106::probe()
{
    // Intentamos enviar un comando simple para verificar
    return writeCommand(SET_DISP | 0x00);
}

void SH1106::clear()
{
    memset(oled_buffer, 0, sizeof(oled_buffer));
}

void SH1106::update()
{
    for (uint8_t page = 0; page < NUM_PAGES; page++)
    {
        setPosition(page, 0);
        writeData(&oled_buffer[page * WIDTH], WIDTH);
    }
}

void SH1106::drawChar(uint8_t x, uint8_t y, char c)
{
    if (c < 32 || c > 126)
        return;
    if (x >= WIDTH || y >= NUM_PAGES)
        return;
    
    // Obtener datos del carácter (5 bytes)
    const uint8_t *font_ptr = &font_5x7[(c - 32) * 5];

    // Escribir en el buffer: página 'y', columnas x hasta x+4
    for (uint8_t i = 0; i < 5; i++)
    {
        if (x + i < WIDTH)
        {
            oled_buffer[y * WIDTH + x + i] = font_ptr[i];
        }
    }
}

void SH1106::drawString(uint8_t x, uint8_t y, const char *str)
{
    while (*str)
    {
        drawChar(x, y, *str++);
        x += 6; // Espacio entre caracteres
        if (x + 5 >= WIDTH)
        {
            x = 0;
            y++;
            if (y >= NUM_PAGES)
                break;
        }
    }
}

void SH1106::drawPixel(uint8_t x, uint8_t y, bool state)
{
    if (x >= WIDTH || y >= HEIGHT) return;
    
    uint8_t page = y / 8; // ¿En qué página está? (0-7)?
    uint8_t bit = y % 8;  // ¿Qué bit dentro del byte? (0-7)?
    
    if (state) {
        oled_buffer[page * WIDTH + x] |= (1 << bit); // Encender bit
    } else {
        oled_buffer[page * WIDTH + x] &= ~(1 << bit); // Apagar bit
    }
}